{% extends "base.html" %}
{% block content %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sofia V2 - Real-Data Trading Interface</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0a0a0a; color: #fff; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; }
        .title { font-size: 28px; font-weight: 600; color: #00ff88; }
        .status { font-size: 14px; color: #888; }
        
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .metric-card { background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 20px; }
        .metric-value { font-size: 24px; font-weight: 700; margin-bottom: 5px; }
        .metric-label { font-size: 12px; color: #888; text-transform: uppercase; }
        .positive { color: #00ff88; }
        .negative { color: #ff4757; }
        .neutral { color: #ffa726; }
        
        .controls { background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 20px; margin-bottom: 30px; }
        .control-row { display: flex; gap: 15px; align-items: center; margin-bottom: 15px; }
        .btn { padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; transition: all 0.3s; }
        .btn-primary { background: #00ff88; color: #000; }
        .btn-primary:hover { background: #00cc6a; }
        .btn-danger { background: #ff4757; color: #fff; }
        .btn-danger:hover { background: #e63946; }
        .btn-secondary { background: #333; color: #fff; }
        .btn-secondary:hover { background: #444; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .positions { background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 20px; }
        .positions-header { font-size: 18px; font-weight: 600; margin-bottom: 20px; color: #00ff88; }
        .position-row { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr; gap: 15px; padding: 12px 0; border-bottom: 1px solid #333; }
        .position-header { font-weight: 600; color: #888; font-size: 12px; text-transform: uppercase; }
        .position-data { font-size: 14px; }
        
        .loading { color: #ffa726; }
        .error { color: #ff4757; }
        .success { color: #00ff88; }
        
        .last-updated { font-size: 12px; color: #666; margin-top: 10px; }
        .freshness { font-size: 11px; color: #888; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">Sofia V2 Real-Data Trading</div>
            <div class="status">
                <div id="connection-status" class="loading">Connecting...</div>
                <div class="freshness">Data freshness: <span id="data-freshness">--</span>s</div>
            </div>
        </div>

        <div class="metrics" id="portfolio-metrics">
            <div class="metric-card">
                <div class="metric-value neutral" id="total-balance">$---.---</div>
                <div class="metric-label">Total Balance</div>
            </div>
            <div class="metric-card">
                <div class="metric-value neutral" id="daily-pnl">$---.--</div>
                <div class="metric-label">Total P&L</div>
            </div>
            <div class="metric-card">
                <div class="metric-value neutral" id="unrealized-pnl">$---.--</div>
                <div class="metric-label">Unrealized P&L</div>
            </div>
            <div class="metric-card">
                <div class="metric-value neutral" id="cash-balance">$---.---</div>
                <div class="metric-label">Cash Available</div>
            </div>
        </div>

        <div class="controls">
            <div class="control-row">
                <button id="start-strategy" class="btn btn-primary">Start Micro Momentum</button>
                <button id="stop-strategy" class="btn btn-danger" disabled>Stop Strategy</button>
                <span id="strategy-status" class="loading">Strategy: Stopped</span>
            </div>
            
            <div class="control-row">
                <button id="manual-buy-btc" class="btn btn-secondary">Buy $100 BTC</button>
                <button id="manual-buy-eth" class="btn btn-secondary">Buy $100 ETH</button>
                <button id="manual-buy-sol" class="btn btn-secondary">Buy $100 SOL</button>
                <span id="manual-status"></span>
            </div>
        </div>

        <div class="positions">
            <div class="positions-header">Live Positions</div>
            <div class="position-row">
                <div class="position-header">Symbol</div>
                <div class="position-header">Quantity</div>
                <div class="position-header">Entry Price</div>
                <div class="position-header">Mark Price</div>
                <div class="position-header">Market Value</div>
                <div class="position-header">P&L</div>
            </div>
            <div id="positions-list">
                <div class="position-row">
                    <div class="position-data">--</div>
                    <div class="position-data">--</div>
                    <div class="position-data">--</div>
                    <div class="position-data">--</div>
                    <div class="position-data">--</div>
                    <div class="position-data">--</div>
                </div>
            </div>
        </div>

        <div class="last-updated">
            Last updated: <span id="last-updated">--</span>
        </div>
    </div>

    <script>
        class TradingUI {
            constructor() {
                this.apiBase = "{{ api_base_url or 'http://localhost:8001' }}";
                this.updateInterval = 5000; // 5 seconds
                this.lastUpdate = 0;
                this.setupEventListeners();
                this.startUpdates();
            }

            setupEventListeners() {
                document.getElementById('start-strategy').addEventListener('click', () => this.toggleStrategy(true));
                document.getElementById('stop-strategy').addEventListener('click', () => this.toggleStrategy(false));
                document.getElementById('manual-buy-btc').addEventListener('click', () => this.manualTrade('BTCUSDT', 'buy', 100));
                document.getElementById('manual-buy-eth').addEventListener('click', () => this.manualTrade('ETHUSDT', 'buy', 100));
                document.getElementById('manual-buy-sol').addEventListener('click', () => this.manualTrade('SOLUSDT', 'buy', 100));
            }

            async toggleStrategy(enabled) {
                try {
                    const response = await fetch(`${this.apiBase}/api/strategy/micro-momo/enable`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ enabled })
                    });
                    
                    const result = await response.json();
                    if (response.ok) {
                        document.getElementById('start-strategy').disabled = enabled;
                        document.getElementById('stop-strategy').disabled = !enabled;
                        document.getElementById('strategy-status').textContent = enabled ? 'Strategy: Running' : 'Strategy: Stopped';
                        document.getElementById('strategy-status').className = enabled ? 'success' : 'loading';
                    } else {
                        this.showError('Strategy toggle failed: ' + result.detail);
                    }
                } catch (error) {
                    this.showError('Strategy toggle error: ' + error.message);
                }
            }

            async manualTrade(symbol, side, usdAmount) {
                try {
                    document.getElementById('manual-status').textContent = 'Executing trade...';
                    document.getElementById('manual-status').className = 'loading';
                    
                    const response = await fetch(`${this.apiBase}/api/trading/paper-order`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ symbol, side, usd_amount: usdAmount })
                    });
                    
                    const result = await response.json();
                    if (response.ok) {
                        document.getElementById('manual-status').textContent = `Trade executed: ${side.toUpperCase()} $${usdAmount} ${symbol}`;
                        document.getElementById('manual-status').className = 'success';
                        this.updatePortfolio(); // Immediate update
                    } else {
                        document.getElementById('manual-status').textContent = 'Trade failed: ' + result.detail;
                        document.getElementById('manual-status').className = 'error';
                    }
                } catch (error) {
                    document.getElementById('manual-status').textContent = 'Trade error: ' + error.message;
                    document.getElementById('manual-status').className = 'error';
                }
            }

            async updatePortfolio() {
                try {
                    // Add cache-busting parameter
                    const cacheBust = Date.now();
                    const response = await fetch(`${this.apiBase}/api/trading/portfolio?_=${cacheBust}`);
                    const result = await response.json();
                    
                    if (response.ok && result.status === 'success') {
                        this.renderPortfolio(result.data);
                        document.getElementById('connection-status').textContent = 'Connected';
                        document.getElementById('connection-status').className = 'success';
                        document.getElementById('last-updated').textContent = new Date().toLocaleTimeString();
                    } else {
                        throw new Error(result.detail || 'Portfolio fetch failed');
                    }
                } catch (error) {
                    document.getElementById('connection-status').textContent = 'Connection Error';
                    document.getElementById('connection-status').className = 'error';
                    console.error('Portfolio update error:', error);
                }
            }

            renderPortfolio(portfolio) {
                // Update metrics
                document.getElementById('total-balance').textContent = this.formatCurrency(portfolio.total_equity);
                document.getElementById('daily-pnl').textContent = this.formatCurrency(portfolio.total_pnl);
                document.getElementById('unrealized-pnl').textContent = this.formatCurrency(portfolio.unrealized_pnl);
                document.getElementById('cash-balance').textContent = this.formatCurrency(portfolio.cash_balance);
                
                // Apply colors
                this.applyPnLColor('daily-pnl', portfolio.total_pnl);
                this.applyPnLColor('unrealized-pnl', portfolio.unrealized_pnl);
                
                // Update positions
                const positionsList = document.getElementById('positions-list');
                positionsList.innerHTML = '';
                
                if (Object.keys(portfolio.positions).length === 0) {
                    positionsList.innerHTML = '<div class="position-row"><div class="position-data" style="grid-column: span 6; text-align: center; color: #888;">No active positions</div></div>';
                } else {
                    for (const [symbol, position] of Object.entries(portfolio.positions)) {
                        const row = document.createElement('div');
                        row.className = 'position-row';
                        
                        row.innerHTML = `
                            <div class="position-data">${symbol}</div>
                            <div class="position-data">${position.quantity.toFixed(6)}</div>
                            <div class="position-data">$${position.avg_entry_price.toFixed(2)}</div>
                            <div class="position-data">$${position.current_price.toFixed(2)}</div>
                            <div class="position-data">$${position.market_value.toFixed(2)}</div>
                            <div class="position-data ${this.getPnLColorClass(position.total_pnl)}">$${position.total_pnl.toFixed(2)} (${position.pnl_percent.toFixed(2)}%)</div>
                        `;
                        
                        positionsList.appendChild(row);
                    }
                }
                
                // Update data freshness
                if (portfolio.updated_at) {
                    const updateTime = new Date(portfolio.updated_at);
                    const freshness = Math.round((Date.now() - updateTime.getTime()) / 1000);
                    document.getElementById('data-freshness').textContent = freshness;
                }
            }

            formatCurrency(value) {
                if (value === null || value === undefined) return '$---.--';
                return '$' + value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            }

            getPnLColorClass(pnl) {
                if (pnl > 0) return 'positive';
                if (pnl < 0) return 'negative';
                return 'neutral';
            }

            applyPnLColor(elementId, value) {
                const element = document.getElementById(elementId);
                element.className = 'metric-value ' + this.getPnLColorClass(value);
            }

            showError(message) {
                document.getElementById('connection-status').textContent = message;
                document.getElementById('connection-status').className = 'error';
            }

            startUpdates() {
                // Initial load
                this.updatePortfolio();
                
                // Periodic updates
                setInterval(() => {
                    this.updatePortfolio();
                }, this.updateInterval);
            }

            async updateStrategyStatus() {
                try {
                    const response = await fetch(`${this.apiBase}/api/strategy/micro-momo/status`);
                    const result = await response.json();
                    
                    if (response.ok && result.status === 'success') {
                        const isRunning = result.data.running;
                        document.getElementById('start-strategy').disabled = isRunning;
                        document.getElementById('stop-strategy').disabled = !isRunning;
                        document.getElementById('strategy-status').textContent = isRunning ? 'Strategy: Running' : 'Strategy: Stopped';
                        document.getElementById('strategy-status').className = isRunning ? 'success' : 'loading';
                    }
                } catch (error) {
                    console.error('Strategy status error:', error);
                }
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            const ui = new TradingUI();
            
            // Update strategy status every 10 seconds
            setInterval(() => ui.updateStrategyStatus(), 10000);
            ui.updateStrategyStatus();
        });
    </script>
</body>
</html>
{% endblock %}
